---
title: "Домашнее задание 1"
author: "Макуха Дмитрий Алексеевич"
date: '1 ноября 2016 г '
output: pdf_document
header-includes:
   - \usepackage[russian]{babel}
---




# Работа с данными. 
***
## Считываем данные во фрейм.
```{r}
data.df <- read.table("http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat") 
```
## Смотрим количество строк у нашего фрейма.
```{r}
nrow(data.df)
```
## Смотрим количество столбцов у нашего фрейма.
```{r}
ncol(data.df)
```
## Смотрим название столбцов у нашего фрейма.
```{r}
colnames(data.df)
```
## Производим обращение к необходимому элементу фрейма [строка, столбец].
```{r}
data.df[5,7] 
```
## Чтение строки фрейма [строка, ].
```{r}
data.df[2,] # 
```
## Меняем названия столбцов.
```{r}
names(data.df) <- c("year", "month", "day", seq(0,23)) 
```
## Смотрим названия столбцов фрейма.
```{r}
names(data.df) 
```
## Смотрим первые n строк фрейма. по дефолту n = 6.
```{r}
head(data.df,20)
```
## Смотрим последние n строк фрейма. по дефолту n = 6.
```{r}
tail(data.df) 
```

### Как мы видим последние 24 столбца - это распределение по часам в одном дне
## Создаем новую колонку под названием daily и складываем туда сумму значений последних 24 колонок описанных ранее. Обращение к колонкам датафрейм$названиеколонки.
```{r}
data.df$daily <- rowSums(data.df[(4:27)]) 
```
### Проверяем по первым 20 строкам что получилось.
```{r}
head(data.df,20)  
```
## Строим гистограмму в которую передаем колонку daily, называем гистограмму Daily Histogram и ось абцисс называем Daily Precipitation.
```{r}
hist(data.df$daily, main = ("Daily Histogram"),xlab = ("Daily Precipitation")) 
```
## Создали булев массив для проверки где значения осадков ниже 0, чего не может быть.
```{r}
newmass <- data.df$daily < 0 
```
## Создаем новый фрейм присвоением значений старого для фиксации найденного бага.
```{r}
fixed.df<- data.df
```
## "Фиксим" значения среднесуточных осадков.
```{r}
fixed.df$daily <- ifelse(fixed.df$daily < 0,0,fixed.df$daily) # меняем 
```
## Строим гистограмму с откорректированными значениями.
```{r, echo=TRUE}
hist(fixed.df$daily, main = ("Fixed daily Histogram"),xlab = ("Daily Precipitation")) #
```


# Синтаксис и типизирование.
***
## Пояснение команд:
### Создаем вектор состоящий из элементов character.
```{r}
v <- c("4", "8", "15", "16", "23", "42")
```
### У character сравнение идет посимвольно начиная с первого. Поэтому максимальным character элементом здесь является "8". 
```{r}
max(v)  
```
### С сортировкой тоже самое, что и в примере выше.
```{r}
sort(v) 
```
### Т.к. элементы не numeric а character, то суммирование невозможно.
```{r, eval=FALSE, include=FALSE}
sum(v)  
```
### В данном примере был добавлен свой пример для лучшего понимания. Данный пример выполняется не корректно в связи с несоответствием типов данных. Тип создаваемого вектора задается типом первого элемента, для того, чтобы в этом убедиться представлено 2 примера выше.
```{r, eval=FALSE, include=FALSE}
v2 <- c("5",7,12)
typeof(v2[2])
v3 <- c(5,7,12)
typeof(v3[2])
v2[2] + v2[3]
```
###  В данном примере создается фрейм данных состоящий из 1 строки и 3 колонок с названиями "z1", "z2", "z3".
```{r}
df3 <- data.frame(z1="5",z2=7,z3=12) 
```
### Тут складываются элементы фрейма располагающиеся на местах [строка, столбец].
```{r}
df3[1,2] + df3[1,3] 
```
### Следом создается лист из 4 элементов.
```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126) 
```
###  Здесь происходит обращение к элементам листа и их сумма. 
```{r}
l4[[2]] + l4[[4]] 
typeof(l4[[2]])
```
###  Затем происходит сумма не элементов а элементов с типом list, вследствие чего происходит ошибка.
```{r, eval=FALSE, include=FALSE}
l4[2] + l4[4] 
typeof(l4[2])
```


# Работа с функциями и операторами.
***
## Числа от 1 до 10000 с инкрементом 372.
```{r}
seq(from = 1, to = 10000, by = 372)
```
## Числа от 1 до 10000 длиной 50, т.е. 50 равноудаленных чисел.
```{r}
seq(from = 1 , to = 10000, length.out = 50)
```
## Происходит повтор всего вектора необходимое количество раз.
```{r}
rep(1:5,times=3) 
```
## А в данном случае происходит повтор каждого элемента вектора необходимое количество раз, а затем переход к следующему элементу.
```{r}
rep(1:5,each=3) 
```














